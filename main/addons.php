<?php
/*
#    File:          /main/addons.php
#    Author:     Caleb Brumfield
#    License:    GNU GPLv3
#    Source:        https://github.com/Cheshire121/StrongWeb-CMS
*
#    Description:
|        This file contains the addons management class as well as 
|     the abstract class for all addons used in the system. 
*    
#    Intensions:
|        To provide a system allowing for "plugable" content
|     that does not constrain said content to text-based resources.
|     The addons class is intended to manage the installation and 
|     uninstallation of addons and their resource files as well as
|     to manage the output generation of these addons.
*
#    Public Member List:
|     addons()        - Constructor,  loads the lis of "enabled" addons from the configrations class.
|
|     RunAddon($addonName)        - Method used to invoke an add-on's runtime code. Specify an enabled addon in $addonName.
|                                - - Returns the data generated by the addons, usally a string-type data.
|    
|     ManageAddon($addonName)    - Method used to invoke an add-on's configuration-panel runtime code. Addon specified by $addonName.
|                                - - Returns the html data generated from the code.
|
|     GetAddonList()             - Method used to scan the 'addons' directory for available/valid addons.
|                                - - Returns an array containing names of valid addons.
|
|     GetEnabledAddonList()        - Filter-Method that filters GetAddonList() and outputs only the "enabled" addons from the list.
|                                - - Returns an array of enabled addons, by name.
|
|     GetDisabledAddonList()        - Filter-Method that filters GetAddonList() and outputs only the "disabled" addons from the list.
|                                - - Returns an array of disabled addons, by name.
|
|     EnableAddon($name)            - Method used to enable an addon specified by $name.
|
|     DisableAddon($name)        - Method used to disable an addon specified by $name.
|
|     processInstall($addonName) - Method used to install a specified addons' resources to the system.
|                                - - Returns an integer used to specify the status of the install.
*/

if( !defined('IN_SWCMS') )
{	exit(); }


class addons
{
    private $addon_dir;
    private $enabled_addons = array();
    
    public function addons()
    {
        global $config;
        
		if( defined('SOFTWARE_INSTALLED') && SOFTWARE_INSTALLED == TRUE )
		{
        	$addonsEnabled = explode( '|', $config->GetConfig( 'ENABLED_ADDONS' ) );
        	foreach( $addonsEnabled as $adn )
        	{
            	$adn = trim($adn);
            	if( !empty($adn) )
            	{    $this->enabled_addons[] = $adn; }
        	}
        }
		else
		{
			$this->enabled_addons[] = NULL;
		}
		
    	$this->addon_dir = ROOT_PATH . "/addons/";
	}
    
    public function RunAddon( $addonName, $args=array() )
    {
        $errorFound = false;
        $addonFile = $this->addon_dir . strtolower($addonName).'/addon.php';    
        
        if( file_exists($addonFile) ) // && in_array($addonName)
        {
            $runName = strtolower($addonName);
            
            @include_once( $addonFile );
            
            if( class_exists( $runName ) && in_array($runName, $this->enabled_addons)  )
            {
                $adn = new $runName();
            
                return $adn->Run( $args );
            }
            elseif( !in_array($runName, $this->enabled_addons) )
            {
                return '';
            }
            else
            {    $errorFound = true; }
        }
        else
        {    $errorFound = true; }
        
        if( $errorFound )
        {
            trigger_error( 'The requested addon could not be found and was not loaded.', E_USER_ERROR );
        }
    }
    
    public function ManageAddon( $addonName )
    {
        $errorFound = false;
        $addonFile = $this->addon_dir . strtolower($addonName).'/addon.php';    
        
        if( file_exists($addonFile) ) // && in_array($addonName)
        {
            $runName = strtolower($addonName);
            
            include_once( $addonFile );
            
            if( class_exists( $runName ) )
            {
                $adn = new $runName();
            
                return $adn->ConfigPanel();
            }
            else
            {    $errorFound = true; }
        }
        else
        {    $errorFound = true; }
        
        if( $errorFound )
        {
            trigger_error( 'The requested addon could not be found and was not loaded.', E_USER_ERROR );
        }
    }
    
    public function GetAddonList()
    {
        global $cache;
		
		$addonsFound = array();
        
		if( $cache->checkCache('adn_lst') )
        {
            $addonsFound = $cache->getCache('adn_lst');
        }
        else
        {
			
        	if ($h = opendir($this->addon_dir))
        	{
            	while (($file = readdir($h)) !== false)
            	{
               		if( $file != '.' && $file != '..')
                	{    
                    	$addonFile = $this->addon_dir.$file.'/addon.php';
                	
                    	if( is_dir($this->addon_dir.$file) && file_exists($addonFile)  )
                    	{
                        	@include_once( $addonFile ); // attempt to include the addon file.
                        	
                        	// Check for the addon's class.
                        	if( class_exists( $file )) // Class name should be the same as the directory name.
                        	{
                        	    $class = new ReflectionClass( $file );
                           		if( $class->isSubclassOf('addon') )
                            	{    $addonsFound[] = $file; }
                        	}
                    	}
                	}
            	}
            	closedir($h);
        	}
			
			$cache->setCache('adn_lst', $addonsFound);
		}
        
		
        return $addonsFound;
    }
    
    public function GetEnabledAddonList()
    {
        $newList = array(0=>"None");
        
        $addons = $this->GetAddonList();
        foreach( $addons as $adn )
        {
            if( !empty($adn) && in_array($adn, $this->enabled_addons) )
            {    $newList[] = $adn; }
        }
        
        return $newList;
    }
    
    public function GetDisabledAddonList()
    {
        $newList = array();
        
        $addons = $this->GetAddonList();
        foreach( $addons as $adn )
        {
            if( !empty($adn) && !in_array($adn, $this->enabled_addons) )
            {    $newList[] = $adn; }
        }
        
        return $newList;
    }
    
    public function EnableAddon( $name )
    {
        global $config;
        
        $addonsEnabled = explode( '|', $config->GetConfig( 'ENABLED_ADDONS' ) );
        
        $newCfgStr = '';
        foreach( $addonsEnabled as $adn )
        {
            $adn = trim( $adn );
            if( !empty($adn) )
            {    $newCfgStr .= $adn.'|'; }
        }
        $newCfgStr .= $name.'|';
        
        $config->SetConfig( 'ENABLED_ADDONS', $newCfgStr );
    }
    
    public function DisableAddon( $name )
    {
        global $config;
        
        $addonsEnabled = explode( '|', $config->GetConfig( 'ENABLED_ADDONS' ) );
        
        $newCfgStr = '';
        foreach( $addonsEnabled as $adn )
        {
            $adn = trim($adn);
            if( !empty($adn) && (strtolower($adn) != strtolower($name)) )
            {    $newCfgStr .= $adn.'|'; }
        }
        
        $config->SetConfig( 'ENABLED_ADDONS', $newCfgStr );
    }
    
    // Function used to install an addon to the system.
    // This will call the addon->Register() method used to set up any database support and config options.
    // Next, the method will call to the addon.xml
    public function processInstall( $addonName )
    {
        global $config, $db;
        
        $tpl = new template( $config->GetConfig('DEFAULT_TEMPLATE') );
        
        $addonName = strtolower( $addonName );
        $errorFound = false;
        
        $addonFile = $this->addon_dir . $addonName.'/addon.php';
        $addonXMLFile = $this->addon_dir . $addonName.'/addon.xml';    
        $addonIMGPath = $this->addon_dir . $addonName.'/images/';    
        
        //Make sure the files exist.
        if( file_exists($addonFile) )
        {
            $runName = strtolower($addonName);
            include_once( $addonFile );
            
            $class = new ReflectionClass( $addonName );
            $is_subclass = $class->isSubclassOf('addon');
            
            // double-check for the class to be the same as the file-name.
            if( class_exists( $runName ) && $is_subclass )
            {
                //Create a new instance of the plugin and get its registry data.
				$adn = new $runName();
                $data = $adn->Register();
                
				if( !empty($data) )
				{
					// Install database assets if there are any. 
					if( isset($data['sql_table']) && !empty($data['sql_tables']) )
					{
						// Create a data dictionary object
						$dict = NewDataDictionary($db);
						
						// Create any database tables needed by this addon
						foreach($data['sql_tables'] as $tblName => $tblData )
						{
							$sqlarray = $dict->CreateTableSQL($tblName, $tblData['sql']);
							
							foreach( $tblData['idx'] as $idxName => $idxFields)
							{
								$sqlarray = array_merge( $sqlarray, $dict->CreateIndexSQL($idxName, $tblName, $idxFields) );
							}
						}
						
						if( is_array($data['sql_records']) && !empty($data['sql_records']) )
						{	$sqlarray = array_merge( $sqlarray, $data['sql_records']); }
						
						//Execute the SQL.
						$dict->ExecuteSQLArray($sqlarray);
					}
					
					if( !empty($data['config']) && is_array($data['config']) )
					{	$config->RegisterConfigFor( $data['config'] , $runName ); }
			
					if( !empty($data['permissions']) && is_array($data['permissions']) )
					{	$permissions->registerPermissions( $data['permissions'] ); }
				}
				
                //Now we use the addon.xml file, if found, to move any resources into place. 
                if( file_exists($addonXMLFile) )
                {
                    @libxml_use_internal_errors( true );
                    $xmlData = simplexml_load_file( $addonXMLFile );
                    
                    if( count(libxml_get_errors()) != 0 )
                    {    return 0x20; } //XML Resource File Error.
                    @libxml_use_internal_errors( false );
                    
                    if( isset($xmlData->images->i) && count($xmlData->images->i) != 0 )
                    {
                        foreach($xmlData->images->i as $imgName )
                        {
                            $imgPath     = $addonIMGPath.$imgName;
                            $newIMGPath = $tpl->GetImagesPath().$addonName."_".$imgName;
                            
                            //The source must exist, attempt the file-copy.
                            if( !copy($imgPath, $newIMGPath) )
                            {    return 0x40; }
                            
                        }
                    }
                    
                    if( isset($xmlData->css) && !empty($xmlData->css) )
                    {    
                        $cssFilePath = $tpl->GetTemplatePath().$addonName.".css";
                        $cssFileContents = base64_decode( $xmlData->css );
                        
                        if( !file_put_contents($cssFilePath, $cssFileContents) )
                        {    return 0x42; }//error installing css resource.
                    }
                    
                    if( isset($xmlData->js) && !empty($xmlData->js) )
                    {
                        $jsFilePath = $tpl->GetTemplatePath().$addonName.".js";
                        $jsFileContents = base64_decode( $xmlData->js );
                        
                        if( !file_put_contents($jsFilePath, $jsFileContents) )
                        {    return 0x44; }//Error installing javascript resource.
                    }
                    
                    if( isset($xmlData->html) && !empty($xmlData->html) )
                    {
                        $htmlFilePath = $tpl->GetTemplatePath().$addonName.".html";
                        $htmlFileContents = base64_decode( $xmlData->html );
                        
                        if( !file_put_contents($htmlFilePath, $htmlFileContents) )
                        {    return 0x48; }//error installing html resource.
                    }
                }
            }
            else
            {    return 0x10; } //Class did not match.
        }
        else
        {    return 0x8; }//File did not exist.
        
        
        return true;
        //create any database-support denoted by the addon.
        //create any configuration for the addon using $config->CreateConfigFor( $nv_pairs, $cfg_for );
        //store css and html files in addon directory. 
    }
    private function processUninstall()
    {
        //If this function is ever fleshed out, it should simply remove any files or images it "installed"
        //No database or configurations should be removed. 
    }
}

//Simple abstract class used to define required class members for addons.
abstract class addon 
{
	public function addon()
	{
	
	}
	
	abstract public function Run( $args );
    abstract public function Register();
    abstract public function ConfigPanel();
    //abstract public function UnRegister();    
}

?>